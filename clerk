#!/usr/bin/env perl

binmode(STDOUT, ":utf8");
use v5.10;
use warnings;
use strict;
use utf8;
use Config::Simple;
use Data::MessagePack;
#use DDP
use Encode qw(decode encode);
use File::Basename;
use File::Path qw(make_path);
use File::Slurper 'read_binary';
use File::stat;
use Try::Tiny;
use FindBin '$Bin';
use FindBin '$Script';
use Getopt::Std;
use HTTP::Date;
use IPC::Run qw( timeout start );
use List::Util qw(any);
use Net::MPD;
use autodie;

my $self="$Bin/$Script";

$ENV{TMUX_TMPDIR}='/tmp/clerk/tmux';
make_path($ENV{TMUX_TMPDIR}) unless(-d $ENV{TMUX_TMPDIR});

my $config_file = $ENV{'HOME'} . "/.config/clerk/clerk.conf";

if ($ENV{CLERK_CONF}) {
	$config_file = $ENV{CLERK_CONF};
}
my $backend="fzf";
# read configuration file
my $cfg = new Config::Simple(filename=>"$config_file");
my $general_cfg = $cfg->param(-block=>"General");
my $mpd_host = $general_cfg->{mpd_host};
my $tmux_config = $general_cfg->{tmux_config};
my $db_file = $general_cfg->{database};
my $songs = $general_cfg->{songs};
my $chunksize = $general_cfg->{chunksize};
my $player = $general_cfg->{player};

my $columns_cfg = $cfg->param(-block=>"Columns");
my $albumartist_l = $columns_cfg->{albumartist_l};
my $album_l = $columns_cfg->{album_l};
my $date_l = $columns_cfg->{date_l};
my $title_l = $columns_cfg->{title_l};
my $track_l = $columns_cfg->{track_l};
my $artist_l = $columns_cfg->{artist_l};

# open connection to MPD
my $mpd = Net::MPD->connect($ENV{MPD_HOST} // $mpd_host // 'localhost');

sub main {
	my %options=();
	getopts("talpfrhuyxz", \%options);
	unless ($options{f}) { 
		$backend = 'rofi'
	} else { 
		$backend = 'fzf';
	}
	if ($options{t} // $options{a} // $options{p} // $options{l} // $options{r} // $options{x} // $options{y} // $options{h} // $options{z} // $options{u}) {
		if    (defined $options{t}) { create_db(); list_db_entries_for("Tracks") }
		elsif (defined $options{a}) { create_db(); list_db_entries_for("Albums") }
		elsif (defined $options{p}) { create_db(); list_playlists() }
		elsif (defined $options{z}) { help() }
		elsif (defined $options{h}) { help_output() }
		elsif (defined $options{x}) {
			create_db();
			system('tmux', 'split-window', '-d', 'clerk', '-f', '-r');
			system('tmux', 'select-pane', '-D');
		}
		elsif (defined $options{y}) {
			system('tmux', 'split-window', '-d', 'clerk', '-f', '-z');
			system('tmux', 'select-pane', '-D');
		}
		elsif (defined $options{r}) { random() }
		elsif (defined $options{l}) { create_db(); list_db_entries_for("Latest") }
		elsif (defined $options{u}) {
			create_db();
		}
	}
	else {
		create_db();
		system('tmux', 'has-session', '-t', 'music');
		if ($? != -0) {
			system('tmux', '-f', $tmux_config, 'new-session', '-s', 'music', '-n', 'albums', '-d', $self, '-a', '-f');
			system('tmux', 'new-window', '-t', 'music', '-n', 'tracks', $self, '-t', '-f');
			system('tmux', 'new-window', '-t', 'music', '-n', 'latest', $self, '-l', '-f');
			system('tmux', 'new-window', '-t', 'music', '-n', 'playlists', $self, '-p', '-f');
			system('tmux', 'new-window', '-t', 'music', '-n', 'queue', $player);
			system('tmux', 'attach', '-t', 'music');
		}
		else {
			system('tmux', 'attach', '-t', 'music');
		}
	}
}

sub help_output {
	my @output = (
		"Usage: clerk [-f] [command]",
		"clerk version 2.0",
		"",
		"Options:",
		"  -f  Use fzf interface. Without other arguments",
		"      this starts a complete tmux interface with tabs.",
		" ",
		"Commands:",
		"  -a  Add/Replace album(s) to queue.",
		"  -l  Add/Replace album(s) to queue (sorted by mtime)",
		"  -t  Add/Replace track(s) to queue.",
		"  -p  Add stored playlist to queue",
		"  -r  Replace current playlist with random songs/album",
		"  -u  Update caches");

	print join("\n", @output), "\n\n";
}

sub create_db {
	# Get database copy and save as messagepack file, if file is either missing
	# or older than latest mpd database update.
	# get number of songs to calculate number of searches needed to copy mpd database
	my $mpd_stats = $mpd->stats();
	my $songcount = $mpd_stats->{songs};
	my $last_update = $mpd_stats->{db_update};

	if (!-f "$db_file" || stat("$db_file")->mtime < $last_update) {
		my $times = int($songcount / $chunksize + 1);
		if ($backend eq "rofi") {
			system('notify-send', '-t', '5', 'clerk', 'Updating Cache File');
		}
		elsif ($backend eq "fzf") {
			print STDERR "::: No cache found or cache file outdated\n";
			print STDERR "::: Chunksize set to $chunksize songs\n";
			print STDERR "::: Requesting $times chunks from MPD\n";
		}
		my @db;
		# since mpd will silently fail, if response is larger than command buffer, let's split the search.
		my $chunk_size = $chunksize;
		for (my $i=0;$i<=$songcount;$i+=$chunk_size) {
			my $endnumber = $i+$chunk_size; 
			my @temp_db = $mpd->search('filename', '', 'window', "$i:$endnumber");
			push @db, @temp_db;
		}

		# only save relevant tags to keep messagepack file small
		# note: maybe use a proper database instead? See list_album function.
		my @filtered = map { $_->{mtime} = str2time($_->{'Last-Modified'}); +{$_->%{qw/Album Artist Date AlbumArtist Title Track uri mtime/}} } @db;
		pack_msgpack(\@filtered);
	}
}

sub help {
	my $help_txt = system('grep', 'bind-key', $tmux_config);
	print "$help_txt\n";
	<STDIN>;
}

sub backend_call {
	$Devel::Trace =1;
	my ($in, $fields, $random) = @_;
	my $input;
	my $out;
	$random //= "ignore";
	$fields //= "1,2,3";
	my %backends = (
		fzf => [ qw(fzf
			--reverse
			--no-sort
			-m
			-e
			-i
			-d
			\t
			--tabstop=4
			+s
			--ansi),
			"--bind=esc:$random",
			"--with-nth=$fields"
		],
		rofi => [
			'rofi',
			'-width',
			'1300',
			'-dmenu',
			'-kb-row-tab',
			'',
			'-kb-move-word-forward',
			'',
			'-kb-row-tab',
			'',
			'-kb-accept-alt',
			'Tab',
			'-multi-select',
			'-no-levensthein-sort',
			'-i',
			'-p',
			'> '
		]
	);
	my $handle = start $backends{$backend} // die('backend not found'), \$input, \$out;
	$input = join "", (@{$in});
	finish $handle or die "No selection";
	return $out;
}

sub pack_msgpack {
	my ($filtered_db) = @_;
	my $msg = Data::MessagePack->pack($filtered_db);
	my $filename = "$db_file";
	open(my $out, '>:raw', $filename) or die "Could not open file '$filename' $!";
	print $out $msg;
	close $out;
}
	
sub unpack_msgpack {
	my $mp = Data::MessagePack->new->utf8();
	my $msgpack = read_binary("$db_file");
	my $rdb = $mp->unpack($msgpack);
	return $rdb;
}

sub random {
	my @queue_cmd = ('tmux', 'findw', '-t', 'music', 'queue');
	my @action_items = ("Album\n", "Tracks\n", "Settings\n");
	my $action = backend_call(\@action_items, "1,2,3", "cancel");
	if ($action eq "Album\n") {
		$mpd->clear();
		my @album_artists = $mpd->list('albumartist');
		my $artist_r = $album_artists[rand @album_artists];
		my @album = $mpd->list('album', 'albumartist', $artist_r);
	 	my $album_r = $album[rand @album];
	 	$mpd->search_add('albumartist', $artist_r, 'album', $album_r);
	 	$mpd->play();
		system(@queue_cmd);
	}
	if ($action eq "Tracks\n") {
		$mpd->clear();
		for (my $i=0; $i <= $songs; $i++) {
			my @artists = $mpd->list('artist');
			my $artist_r = $artists[rand @artists];
			my @albums = $mpd->list('album', 'artist', $artist_r);
			my $album_r = $albums[rand @albums];
			my @tracks = $mpd->search('artist', $artist_r, 'album', $album_r);
			my $track_r = $tracks[rand @tracks];
			my $foo = $track_r->{uri};
			$mpd->add($foo);
			system(@queue_cmd);
			$mpd->play();
		}
		system(@queue_cmd);
		$mpd->play();
	}
	if ($action eq "Settings\n") {
		my @action_items = ("5\n", "10\n", "15\n", "20\n", "25\n", "30\n");
		my $action = backend_call(\@action_items);
		chomp $action;
		$cfg->param("General.songs", $action);
		$cfg->save();
	}
}

sub do_action {
	$Devel::Trace =1;
	my ($in, $context) = @_;
	my @action_items = ("Add\n", "Replace\n");
	my $action = backend_call(\@action_items);
	if ($action eq "Replace\n") {
		$mpd->clear();
	}
	my $input;
	if ($context eq "playlist") {
		chomp $in;
		$mpd->load("$in");
	} elsif ($context eq "tracks") {
		foreach my $line (split /\n/, $in) {
			my $uri = (split /[\t\n]/, $line)[-1];
			$uri = decode('UTF-8', $uri );
			$mpd->add($uri);
		}
	}
	if ($action eq "Replace\n") {
		$mpd->play();
	}
	my @queue_cmd = ('tmux', 'findw', '-t', 'music', 'queue');
	system(@queue_cmd);
}

sub list_playlists {
	my @playlists = $mpd->list_playlists();
	my $output = formatted_playlists(\@playlists);

	for (;;) {
		my $out = backend_call($output);
		do_action($out, "playlist", "ignore");
	}
}

sub formatted_albums {
	my ($rdb, $sorted) = @_;

	my %uniq_albums;
	for my $i (@$rdb) {
		my $newkey = join "", $i->@{qw/AlbumArtist Date Album/};
		if (!exists $uniq_albums{$newkey}) {
			my $dir = (dirname($i->{uri}) =~ s/\/CD.*$//r);
			$uniq_albums{$newkey} = {$i->%{qw/AlbumArtist Album Date mtime/}, Dir => $dir};
		} else {
			if ($uniq_albums{$newkey}->{'mtime'} < $i->{'mtime'}) {
				$uniq_albums{$newkey}->{'mtime'} = $i->{'mtime'}
			}
		}
	}

	my @albums;
	my $fmtstr = join "", map {"%-${_}.${_}s\t"} ($albumartist_l, $date_l, $album_l);

	my @skeys;
	if ($sorted) {
		@skeys = sort { $uniq_albums{$b}->{mtime} <=> $uniq_albums{$a}->{mtime} } keys %uniq_albums;
	} else {
		@skeys = sort keys %uniq_albums;
	}

	for my $k (@skeys) {
		my @vals = ((map { $_ // "Unknown" } $uniq_albums{$k}->@{qw/AlbumArtist Date Album/}), $uniq_albums{$k}->{Dir});
		my $strval = sprintf $fmtstr."%s\n", @vals;
		push @albums, $strval;
	}

	return \@albums;
}

sub formatted_tracks {
	my ($rdb) = @_;
	my $fmtstr = join "", map {"%-${_}.${_}s\t"} ($track_l, $title_l, $artist_l, $album_l);
	my @tracks = map {
		sprintf $fmtstr."%-s\n", (map { $_ // "Unknown" } $_->@{qw/Track Title Artist Album/}), $_->{uri};
#		sprintf $fmtstr."%-s\n", $_->@{qw/Track Title Artist Album uri/}
	} @{$rdb};

	return \@tracks;
}

sub formatted_playlists {
    my ($rdb) = @_;
    my @playlists = map {
    	sprintf "%s\n", $_->{playlist}
    } @{$rdb};

    return \@playlists;
}

sub list_db_entries_for {
	$Devel::Trace =1;
	my ($kind) = @_;
	die "Wrong kind" unless any {; $_ eq $kind} qw/Albums Latest Tracks/;

	my $rdb = unpack_msgpack();
	my %fields = (Albums=> "1,2,3", Latest => "1,2,3", Tracks => "1,2,3,4");
	my %formater = (
		Albums => sub {formatted_albums(@_, 0)},
		Latest => sub {formatted_albums(@_, 1)},
		Tracks => \&formatted_tracks
	);

	my $output = $formater{$kind}->($rdb);
	if ($backend eq "rofi") {
		my $out = backend_call($output, $fields{$kind});
		do_action($out, "tracks", "ignore");
	}
	elsif ($backend eq "fzf") {
	for (;;) {
		create_db();
		my $out = backend_call($output, $fields{$kind});
		try {
			do_action($out, "tracks", "ignore");
		}
	}
}
}

main;
